<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebBLE Sensor Data</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <style>
    #map {
      height: 400px;
      width: 100%;
      margin-top: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
    }

    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
upda
    .content {
      max-width: 500px;
      width: 100%;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      text-align: center;
    }

    h1 {
      font-size: 1.5em;
      margin-bottom: 20px;
    }

    button {
      padding: 10px 15px;
      margin: 10px 0;
      border: none;
      border-radius: 5px;
      background-color: #007BFF;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #0056b3;
    }

    input {
      width: calc(100% - 22px);
      padding: 10px;
      margin: 10px 0;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    #sensorData {
      margin-top: 20px;
      text-align: left;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .value-box {
      margin: 5px;
      flex: 1;
      text-align: center;
      height: 60px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    #sensorDataHistory {
      margin-top: 20px;
      display: none;
      text-align: left;
    }

    #loading {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #007BFF;
      z-index: 9999;
    }

    /* Arrow container without circle */
    .arrow-container {
      position: relative;
      width: 150px;
      height: 150px;
      margin: 20px auto;
      background: transparent;  /* Removed circle background */
      border-radius: 0;
      box-shadow: none;
      border: none;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .arrow-svg {
      width: 60px;
      height: 60px;
      transition: transform 0.3s ease;
      transform-origin: 50% 50%;
    }

    .controls {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.4);
      padding-top: 60px;
    }

    .modal-content {
      background-color: #fefefe;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
    }

    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }

    .close:hover,
    .close:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }

    .position-info {
      margin-top: 20px;
      background: #fff;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      max-width: 400px;
      text-align: center;
    }

    .position-info h3 {
      margin: 10px 0 5px;
    }

    #measurementStatus {
      width: 100%;
      max-width: 500px;
      background-color: #fffae6;
      color: #8a6d3b;
      border: 1px solid #faebcc;
      padding: 12px 20px;
      margin-bottom: 15px;
      border-radius: 6px;
      text-align: center;
      font-weight: bold;
      box-shadow: 0 0 6px rgba(250, 235, 204, 0.7);
    }

    /* Hide all devices goal list permanently */
    .goal-list {
      display: none;
    }
    .distance-box {
      margin-top: 15px;
      background: #e7f3ff;
      color: #004085;
      border: 1px solid #b8daff;
      border-radius: 6px;
      padding: 12px;
      font-weight: bold;
      max-width: 400px;
      text-align: center;
      box-shadow: 0 0 6px rgba(0, 123, 255, 0.3);
    }
  </style>
</head>
<body>

  <h1>ESP32 S3 Feather Sensor Data</h1>

  <!-- Standing textbox with measurement advice -->
  <div id="measurementStatus">Loading measurement status...</div>

  <div id="loading">Loading Kriging Traverse...</div>

  <button id="enableCompassBtn">Enable Compass</button>

  <div class="arrow-container" title="Arrow points towards goal">
    <svg id="arrow" class="arrow-svg" viewBox="0 0 100 100" width="100" height="100">
      <polygon points="50,10 90,90 50,70 10,90" fill="red"/>
    </svg>

  </div>

  <div class="position-info">
    <h3>Goal Position (Device <span id="mainDeviceId">-</span>)</h3>
    <p id="goalPosition">Lat: —, Lon: —</p>

    <h3>Current Position</h3>
    <p id="currentPosition">Lat: —, Lon: —</p>
  </div>

  <div id="distanceBox" class="distance-box">
    Distance to goal: —
  </div>
  <!-- All devices goal list hidden permanently -->
  <div class="goal-list" id="allGoalPositions">
    <h3>All Devices Goal Positions</h3>
    <div id="goalDevice0" class="goal-item">Device 0: Lat: —, Lon: —</div>
    <div id="goalDevice1" class="goal-item">Device 1: Lat: —, Lon: —</div>
    <div id="goalDevice2" class="goal-item">Device 2: Lat: —, Lon: —</div>
  </div>

  <button id="cannotgo">Can Not Go forward</button>
  <button id="connect">Connect to ESP32</button>
  <input id="commandInput" placeholder="Enter command"/>
  <button id="submitCommandBtn">Submit Command</button>
  <button id="getReadingBtn">Get Reading</button>
  <input id="VMCInput" placeholder="Enter VMC"/>
  <div id="sensorData">
    <div class="value-box">VWC: <span id="value1"></span></div>
    <div class="value-box">Temp: <span id="value2"></span></div>
    <div class="value-box">EC: <span id="value3"></span></div>
  </div>

  <h3 id="viewDataHistory" style="cursor: pointer;">View Data History</h3>
  <div id="sensorDataHistory"></div>
  <div id="coordinateDIV" style="display: none;"></div>

  <div id="readingModal" class="modal">
    <div class="modal-content">
      <span class="close" id="closeModal">&times;</span>
      <h2>Take a Reading</h2>
      <p>You have reached your goal! Would you like to take a reading now?</p>
      <button id="confirmReadingBtn">Yes, take a reading</button>
      <button id="cancelReadingBtn">No, later</button>
    </div>
  </div>

  <script>
    let deviceHeading = 0;
    let goalBearing = null;
    let deviceID = -1;
    let devicesWithReadings = new Set();

    // Elements
    const measurementStatusEl = document.getElementById("measurementStatus");
    const mainDeviceIdEl = document.getElementById("mainDeviceId");
    const coordinateD = document.getElementById("coordinateDIV");

    async function setupDeviceOrientation() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const response = await DeviceOrientationEvent.requestPermission();
          if (response === 'granted') {
            window.addEventListener('deviceorientationabsolute', handleOrientation, true);
            window.addEventListener('deviceorientation', handleOrientation, true);
            console.log('DeviceOrientation permission granted.');
          } else {
            alert('Permission to access device orientation was denied.');
          }
        } catch (error) {
          console.error('Error requesting DeviceOrientation permission:', error);
        }
      } else {
        window.addEventListener('deviceorientationabsolute', handleOrientation, true);
        window.addEventListener('deviceorientation', handleOrientation, true);
      }
    }

    function handleOrientation(event) {
      if (event.absolute || event.webkitCompassHeading !== undefined) {
        deviceHeading = event.webkitCompassHeading || 0;
      } else if (event.alpha !== null) {
        deviceHeading = 360 - event.alpha;
      }
      if (goalBearing !== null) {
        updateArrow(goalBearing);
      } else {
        updateArrow(deviceHeading);
      }
    }

    const SERVICE_UUID = '91bad492-b950-4226-aa2b-4ede9fa42f59';
    const CHAR_UUID_SENSOR_DATA = '98e025d3-23e5-4b62-9916-cc6c330c84ac';
    const CHAR_UUID_COMMAND = 'f78ebbff-c8b7-4107-93de-889a6a06d408';

    let commandCharacteristic;
    let pollingInterval = null;

    document.getElementById('getReadingBtn').addEventListener('click', generateMockSensorData);

    document.getElementById('connect').addEventListener('click', async () => {
      try {
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ services: [SERVICE_UUID] }]
        });

        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);

        const sensorDataCharacteristic = await service.getCharacteristic(CHAR_UUID_SENSOR_DATA);
        commandCharacteristic = await service.getCharacteristic(CHAR_UUID_COMMAND);

        await sensorDataCharacteristic.startNotifications();
        sensorDataCharacteristic.addEventListener('characteristicvaluechanged', handleSensorData);

        console.log('Connected to ESP32 S3 Feather');
        document.getElementById("connect").style.display = 'none';
      } catch (error) {
        console.error('Error connecting to device:', error);
      }
    });

    function getGeoData(callback) {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => callback(null, position),
          (error) => {
            let errorMsg;
            switch(error.code) {
              case error.PERMISSION_DENIED:
                errorMsg = "User denied the request for Geolocation.";
                break;
              case error.POSITION_UNAVAILABLE:
                errorMsg = "Location information is unavailable.";
                break;
              case error.TIMEOUT:
                errorMsg = "The request to get user location timed out.";
                break;
              default:
                errorMsg = "An unknown error occurred.";
                break;
            }
            callback(new Error(errorMsg), null);
          }
        );
      } else {
        callback(new Error("Geolocation not supported."), null);
      }
    }
    function startLocationTracking() {
      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(
          (position) => {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            document.getElementById("currentPosition").innerText =
              `Lat: ${lat.toFixed(6)}, Lon: ${lon.toFixed(6)}`;

            // Optionally update compass as well
            if (deviceID !== -1) {
              updateAllGoalsAndCompass(lat,lon);
            }
          },
          (error) => {
            console.error("Geolocation error:", error);
            document.getElementById("currentPosition").innerText =
              "Lat: —, Lon: — (location unavailable)";
          },
          {
            enableHighAccuracy: true,
            maximumAge: 1000,
            timeout: 5000,
          }
        );
      } else {
        console.error("Geolocation not supported.");
        document.getElementById("currentPosition").innerText =
          "Lat: —, Lon: — (not supported)";
      }
    }


    function handleSensorData(event) {
      const value = event.target.value;
      const data = new TextDecoder().decode(value);
      const sensorDataDiv = document.getElementById('sensorDataHistory');
      const now = new Date();
      const dateTimeString = now.toLocaleTimeString();

      getGeoData((geoError, position) => {
        if (geoError) {
          console.error("Geolocation error:", geoError);
          coordinateD.innerHTML = `ERROR: ${geoError.message}`;
          return;
        }

        const lat = position.coords.latitude;
        const lon = position.coords.longitude;

        coordinateD.innerHTML = `${lat},${lon}`;

        const values = data.split(',');
        const combinedData = data + "," + dateTimeString + "," + lat + "," + lon;

        sensorDataDiv.innerHTML =
          `${dateTimeString} - Sensor Data: ${data} <br>` +
          sensorDataDiv.innerHTML;

        if (values.length >= 3) {
          document.getElementById('value1').innerText = (values[0]);
          document.getElementById('value2').innerText = values[1];
          document.getElementById('value3').innerText = (values[2] / 1000).toFixed(3);

          fetch("/sendSensorValues", {
            method: "POST",
            headers: {
              'Accept': 'application/json, text/plain, */*',
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              sensorValue: {
                VWC: values[0],
                TEMP: values[1],
                EC: values[2],
                Longitude: lon,
                Latitude: lat,
                Timestamp: dateTimeString
              },
              deviceID: deviceID
            })
          })
          .then(response => response.json())
          .then(data => {
            console.log("Server Response:", data);
            if (data.deviceID !== undefined && data.deviceID !== -1) {
              if (deviceID === -1) {
                // On first assigned ID, update main device ID in UI
                mainDeviceIdEl.innerText = data.deviceID;
                deviceID = data.deviceID;
                devicesWithReadings.add(deviceID);
                updateMeasurementStatus();
                updateAllGoalsAndCompass(); // <-- ADD THIS!
                console.log("Updated deviceID to", deviceID);
              } else {
                deviceID = data.deviceID;
                devicesWithReadings.add(deviceID);
                updateMeasurementStatus();
              }
            }

            document.getElementById("currentPosition").innerText =
              `Lat: ${lat.toFixed(6)}, Lon: ${lon.toFixed(6)}`;
            fetch('/krigingStatus')
              .then(response => response.json())
              .then(data => {
                if (!data.running) {
                  clearInterval(pollingInterval);
                  document.getElementById('loading').style.display = "none";
                  document.querySelector('.arrow-container').style.display = "flex";
                  updateMeasurementStatus();
                  updateAllGoalsAndCompass();
                }

              })
              .catch(err => console.error(err));
          })
          .catch(error => console.error(error));
        }
      });
    }

    function sendCommand(command) {
      if (commandCharacteristic) {
        const commandData = new TextEncoder().encode(command);
        commandCharacteristic.writeValue(commandData)
          .then(() => {
            console.log(`Command "${command}" sent to the device.`);
          })
          .catch(error => {
            console.error('Error sending command:', error);
          });
      } else {
        console.error('Command characteristic not available.');
      }
    }

    document.getElementById('submitCommandBtn').addEventListener('click', () => {
      sendCommand(document.getElementById("commandInput").value);
    });

    document.getElementById('viewDataHistory').addEventListener('click', () => {
      const sensorDataHistory = document.getElementById('sensorDataHistory');
      sensorDataHistory.style.display =
        sensorDataHistory.style.display === 'none' ? 'block' : 'none';
    });

    document.getElementById("cannotgo").addEventListener('click', () => {
      if (confirm("Is it shorter to go right?")) {
        updateArrow(90);
      } else {
        updateArrow(270);
      }
    });

    function updateArrow(goalBearingInput) {
      goalBearing = goalBearingInput;
      const relativeAngle = (goalBearing - deviceHeading + 360) % 360;
      const arrow = document.getElementById('arrow');
      arrow.style.transform =
        `rotate(${relativeAngle}deg)`;
    }

    function resetArrow() {
      goalBearing = null;
      updateArrow(0);
    }

    function startPollingKrigingStatus() {
      document.querySelector('.arrow-container').style.display = "none";
      document.getElementById('loading').style.display = "block";

      pollingInterval = setInterval(() => {
        fetch('/krigingStatus')
          .then(response => response.json())
          .then(data => {
            if (!data.running) {
              clearInterval(pollingInterval);
              document.getElementById('loading').style.display = "none";
              document.querySelector('.arrow-container').style.display = "flex";
              updateAllGoalsAndCompass();
            }
          })
          .catch(err => console.error(err));
      }, 2000);
    }

    async function updateMeasurementStatus() {
      try {
        const response = await fetch('/krigingStatus');
        const data = await response.json();

        const count = data.deviceCount ?? 0;

        if (count < 3) {
          measurementStatusEl.textContent = 
            `Only ${count} device(s) reporting. Please take more measurements (need at least 3).`;
        } else {
          measurementStatusEl.textContent = 
            "3 or more devices reporting. You may proceed with measurements.";
        }
      } catch (e) {
        console.error("Error updating measurement status", e);
        measurementStatusEl.textContent = "Could not load device count.";
      }
    }


    async function fetchGoalForDevice(id) {
      try {
        const response = await fetch(`/getGoal/${id}`);
        if (!response.ok) {
          throw new Error(`No goal for device ${id}`);
        }
        const data = await response.json();
        return data;
      } catch (e) {
        console.warn(e);
        return null;
      }
    }

    async function updateAllGoalsAndCompass(currentLat, currentLon) {
      if (deviceID === -1) {
        document.getElementById('goalPosition').innerText = "Lat: —, Lon: —";
        document.getElementById('distanceBox').textContent = "Distance to goal: —";
        updateArrow(0);
        return;
      }

      const currentGoal = await fetchGoalForDevice(deviceID);
      if (currentGoal) {
        document.getElementById('goalPosition').innerText =
          `Lat: ${currentGoal.lat.toFixed(6)}, Lon: ${currentGoal.lon.toFixed(6)}`;

        const goalLat = currentGoal.lat;
        const goalLon = currentGoal.lon;

        const bearing = calculateBearing(
          currentLat,
          currentLon,
          goalLat,
          goalLon
        );

        const distance = haversineDistance(
          currentLat,
          currentLon,
          goalLat,
          goalLon
        );

        updateArrow(bearing);

        document.getElementById('distanceBox').textContent =
          `Distance to goal: ${distance.toFixed(1)} meters`;
      } else {
        document.getElementById('goalPosition').innerText = "Lat: —, Lon: —";
        document.getElementById('distanceBox').textContent = "Distance to goal: —";
        updateArrow(0);
      }
    }


    function calculateBearing(lat1, lon1, lat2, lon2) {
      const dLon = (lon2 - lon1) * Math.PI / 180;
      lat1 = lat1 * Math.PI / 180;
      lat2 = lat2 * Math.PI / 180;
      const y = Math.sin(dLon) * Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) -
                Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
      let brng = Math.atan2(y, x);
      brng = brng * 180 / Math.PI;
      return (brng + 360) % 360;
    }
    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // radius of Earth in meters
      const toRad = angle => angle * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);

      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRad(lat1)) *
          Math.cos(toRad(lat2)) *
          Math.sin(dLon / 2) *
          Math.sin(dLon / 2);

      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }


    function generateMockSensorData() {
      const vmc = document.getElementById('VMCInput').value || "1";
      const ec = (Math.random() * 2000).toFixed(2);
      const temp = (20 + Math.random() * 10).toFixed(2);
      const mockData = `${vmc},${temp},${ec}`;
      const encoder = new TextEncoder();
      const fakeEvent = {
        target: {
          value: encoder.encode(mockData)
        }
      };
      handleSensorData(fakeEvent);
    }

    document.getElementById('enableCompassBtn').addEventListener('click', () => {
      setupDeviceOrientation();
      document.getElementById('enableCompassBtn').style.display = 'none';
    });

    setInterval(updateMeasurementStatus, 5000);
    startLocationTracking();
</script>
</body>
</html>