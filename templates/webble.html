<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WebBLE Sensor Data</title>
  <link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>
<style>
  #map {
    height: 400px;
    width: 100%;
    margin-top: 20px;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
  }
</style>

  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    .content {
      max-width: 500px;
      width: 100%;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      text-align: center;
    }

    h1 {
      font-size: 1.5em;
      margin-bottom: 20px;
    }

    button {
      padding: 10px 15px;
      margin: 10px 0;
      border: none;
      border-radius: 5px;
      background-color: #007BFF;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #0056b3;
    }

    input {
      width: calc(100% - 22px);
      padding: 10px;
      margin: 10px 0;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    #sensorData {
      margin-top: 20px;
      text-align: left;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .value-box {
      margin: 5px;
      flex: 1;
      text-align: center;
      height: 60px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    #sensorDataHistory {
      margin-top: 20px;
      display: none;
      text-align: left;
    }

    #loading {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      color: #007BFF;
      z-index: 9999;
    }

    .compass-container {
      position: relative;
      width: 250px;
      height: 250px;
      margin: 20px auto;
    }

    .compass {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background-color: #fff;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      border: 8px solid #333;
      box-sizing: border-box;
    }

    .compass::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      background: conic-gradient(
        #ff0000 0deg 15deg,
        #333 15deg 75deg,
        #ff0000 75deg 105deg,
        #333 105deg 165deg,
        #ff0000 165deg 195deg,
        #333 195deg 255deg,
        #ff0000 255deg 285deg,
        #333 285deg 345deg,
        #ff0000 345deg 360deg
      );
      opacity: 0.2;
    }

    .compass-ring {
      position: absolute;
      width: 90%;
      height: 90%;
      border-radius: 50%;
      top: 5%;
      left: 5%;
      border: 2px solid #333;
      box-sizing: border-box;
    }

    .compass-point {
      position: absolute;
      font-weight: bold;
      font-size: 16px;
      color: #333;
    }

    .compass-point.north {
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
    }

    .compass-point.east {
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
    }

    .compass-point.south {
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
    }

    .compass-point.west {
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
    }

    .arrow {
      position: absolute;
      width: 10px;
      height: 40%;
      background-color: red;
      left: 50%;
      bottom: 50%;
      transform-origin: bottom;
      transform: translateX(-50%) translateY(10px) rotate(0deg);
      z-index: 10;
      border-radius: 5px 5px 0 0;
      transition: transform 0.3s ease;
    }

    .arrow::before {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      background-color: red;
      border-radius: 50%;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
    }

    .controls {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.4);
      padding-top: 60px;
    }

    .modal-content {
      background-color: #fefefe;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 80%;
    }

    .close {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }

    .close:hover,
    .close:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }

    .position-info {
      margin-top: 20px;
      background: #fff;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      max-width: 400px;
      text-align: center;
    }

    .position-info h3 {
      margin: 10px 0 5px;
    }
  </style>
</head>
<body>

  <h1>ESP32 S3 Feather Sensor Data</h1>

  <div id="loading">Loading Kriging Traverse...</div>
  <button id="enableCompassBtn">Enable Compass</button>

  <div class="compass-container">
    <div class="compass">
      <div class="compass-ring"></div>
      <div class="compass-point north"></div>
      <div class="compass-point east"></div>
      <div class="compass-point south"></div>
      <div class="compass-point west"></div>
      <div class="arrow" id="arrow"></div>
    </div>
  </div>

  <div class="position-info">
    <h3>Goal Position</h3>
    <p id="goalPosition">Lat: —, Lon: —</p>

    <h3>Current Position</h3>
    <p id="currentPosition">Lat: —, Lon: —</p>
  </div>

  <button id="cannotgo">Can Not Go forward</button>
  <button id="connect">Connect to ESP32</button>
  <input id="commandInput" placeholder="Enter command"/>
  <button id="submitCommandBtn">Submit Command</button>
  <button id="getReadingBtn">Get Reading</button>
  <h1> For initial reading, have 2 devices go to opposite corners and any extras can go towards the middle</h1>
  <input id="VMCInput" placeholder="Enter VMC"/>
  <div id="sensorData">
    <div class="value-box">VWC: <span id="value1"></span></div>
    <div class="value-box">Temp: <span id="value2"></span></div>
    <div class="value-box">EC: <span id="value3"></span></div>
  </div>

  <h3 id="viewDataHistory" style="cursor: pointer;">View Data History</h3>
  <div id="sensorDataHistory"></div>
  <div id="coordinateDIV" style="display: none;"></div>

  <div id="readingModal" class="modal">
    <div class="modal-content">
      <span class="close" id="closeModal">&times;</span>
      <h2>Take a Reading</h2>
      <p>You have reached your goal! Would you like to take a reading now?</p>
      <button id="confirmReadingBtn">Yes, take a reading</button>
      <button id="cancelReadingBtn">No, later</button>
    </div>
  </div>

  <script>
    let deviceHeading = 0;
    let goalBearing = null;

    async function setupDeviceOrientation() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const response = await DeviceOrientationEvent.requestPermission();
          if (response === 'granted') {
            window.addEventListener('deviceorientationabsolute', handleOrientation, true);
            window.addEventListener('deviceorientation', handleOrientation, true);
            console.log('DeviceOrientation permission granted.');
          } else {
            alert('Permission to access device orientation was denied.');
          }
        } catch (error) {
          console.error('Error requesting DeviceOrientation permission:', error);
        }
      } else {
        window.addEventListener('deviceorientationabsolute', handleOrientation, true);
        window.addEventListener('deviceorientation', handleOrientation, true);
      }
    }

    

    function handleOrientation(event) {
      if (event.absolute || event.webkitCompassHeading !== undefined) {
        deviceHeading = event.webkitCompassHeading || 0;
      } else if (event.alpha !== null) {
        deviceHeading = 360 - event.alpha;
      }
      if (goalBearing !== null) {
        updateCompass(goalBearing);
      } else {
        updateCompass(deviceHeading);
      }
    }

    const SERVICE_UUID = '91bad492-b950-4226-aa2b-4ede9fa42f59';
    const CHAR_UUID_SENSOR_DATA = '98e025d3-23e5-4b62-9916-cc6c330c84ac';
    const CHAR_UUID_COMMAND = 'f78ebbff-c8b7-4107-93de-889a6a06d408';

    let commandCharacteristic;
    let deviceID = -1;
    let coordinateD = document.getElementById("coordinateDIV");
    let pollingInterval = null;

    document.getElementById('getReadingBtn').addEventListener('click', generateMockSensorData);

    document.getElementById('connect').addEventListener('click', async () => {
      try {
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ services: [SERVICE_UUID] }]
        });

        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        
        const sensorDataCharacteristic = await service.getCharacteristic(CHAR_UUID_SENSOR_DATA);
        commandCharacteristic = await service.getCharacteristic(CHAR_UUID_COMMAND);

        await sensorDataCharacteristic.startNotifications();
        sensorDataCharacteristic.addEventListener('characteristicvaluechanged', handleSensorData);

        console.log('Connected to ESP32 S3 Feather');
        document.getElementById("connect").style.display = 'none';
      } catch (error) {
        console.error('Error connecting to device:', error);
      }
    });

    function getGeoData(callback) {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (position) => callback(null, position),
          (error) => {
            let errorMsg;
            switch(error.code) {
              case error.PERMISSION_DENIED:
                errorMsg = "User denied the request for Geolocation.";
                break;
              case error.POSITION_UNAVAILABLE:
                errorMsg = "Location information is unavailable.";
                break;
              case error.TIMEOUT:
                errorMsg = "The request to get user location timed out.";
                break;
              default:
                errorMsg = "An unknown error occurred.";
                break;
            }
            callback(new Error(errorMsg), null);
          }
        );
      } else {
        callback(new Error("Geolocation not supported."), null);
      }
    }

    function handleSensorData(event) {
      const value = event.target.value;
      const data = new TextDecoder().decode(value);
      const sensorDataDiv = document.getElementById('sensorDataHistory');
      const now = new Date();
      const dateTimeString = now.toLocaleTimeString();

      getGeoData((geoError, position) => {
        if (geoError) {
          console.error("Geolocation error:", geoError);
          coordinateD.innerHTML = `ERROR: ${geoError.message}`;
          return;
        }

        const lat = position.coords.latitude;
        const lon = position.coords.longitude;

        coordinateD.innerHTML = `${lat},${lon}`;

        const values = data.split(',');
        const combinedData = data + "," + dateTimeString + "," + lat + "," + lon;

        sensorDataDiv.innerHTML =
          `${dateTimeString} - Sensor Data: ${data} <br>` +
          sensorDataDiv.innerHTML;

        if (values.length >= 3) {
          document.getElementById('value1').innerText = (values[0]);
          document.getElementById('value2').innerText = values[1];
          document.getElementById('value3').innerText = (values[2] / 1000).toFixed(3);

          fetch("/sendSensorValues", {
            method: "POST",
            headers: {
              'Accept': 'application/json, text/plain, */*',
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              sensorValue: {
                VWC: values[0],
                TEMP: values[1],
                EC: values[2],
                Longitude: lon,
                Latitude: lat,
                Timestamp: dateTimeString
              },
              deviceID: deviceID
            })
          })
          .then(response => response.json())
          .then(data => {
            console.log("Server Response:", data);
            if (data.deviceID !== undefined && data.deviceID !== -1) {
              deviceID = data.deviceID;
              console.log("Updated deviceID to", deviceID);
            }
            document.getElementById("currentPosition").innerText =
              `Lat: ${lat.toFixed(6)}, Lon: ${lon.toFixed(6)}`;
            fetch('/krigingStatus')
              .then(response => response.json())
              .then(data => {
                if (!data.running) {
                  clearInterval(pollingInterval);
                  document.getElementById('loading').style.display = "none";
                  document.querySelector('.compass').style.display = "block";
                  getGoalAndUpdateCompass();
                }
              })
              .catch(err => console.error(err));
          })
          .catch(error => console.error(error));
        }
      });
    }

    function sendCommand(command) {
      if (commandCharacteristic) {
        const commandData = new TextEncoder().encode(command);
        commandCharacteristic.writeValue(commandData)
          .then(() => {
            console.log(`Command "${command}" sent to the device.`);
          })
          .catch(error => {
            console.error('Error sending command:', error);
          });
      } else {
        console.error('Command characteristic not available.');
      }
    }

    document.getElementById('submitCommandBtn').addEventListener('click', () => {
      sendCommand(document.getElementById("commandInput").value);
    });

    document.getElementById('viewDataHistory').addEventListener('click', () => {
      const sensorDataHistory = document.getElementById('sensorDataHistory');
      sensorDataHistory.style.display =
        sensorDataHistory.style.display === 'none' ? 'block' : 'none';
    });

    document.getElementById("cannotgo").addEventListener('click', () => {
      if (confirm("Is it shorter to go right?")) {
        updateCompass(90);
      } else {
        updateCompass(270);
      }
    });

    function updateCompass(goalBearingInput) {
      goalBearing = goalBearingInput;
      const relativeAngle = (goalBearing - deviceHeading + 360) % 360;
      const arrow = document.getElementById('arrow');
      arrow.style.transform =
        `translateX(-50%) translateY(10px) rotate(${relativeAngle}deg)`;
    }

    function resetCompass() {
      goalBearing = null;
      updateCompass(0);
    }

    function startPollingKrigingStatus() {
      document.querySelector('.compass').style.display = "none";
      document.getElementById('loading').style.display = "block";

      pollingInterval = setInterval(() => {
        fetch('/krigingStatus')
          .then(response => response.json())
          .then(data => {
            if (!data.running) {
              clearInterval(pollingInterval);
              document.getElementById('loading').style.display = "none";
              document.querySelector('.compass').style.display = "block";
              getGoalAndUpdateCompass();
            }
          })
          .catch(err => console.error(err));
      }, 2000);
    }

    function getGoalAndUpdateCompass() {
      if (deviceID === -1) {
        console.error("Device ID not yet assigned.");
        return;
      }

      fetch(`/getGoal/${deviceID}`)
        .then(response => response.json())
        .then(goal => {
          if (goal.error) {
            console.error(goal.error);
            return;
          }
          document.getElementById("goalPosition").innerText =
            `Lat: ${goal.lat.toFixed(6)}, Lon: ${goal.lon.toFixed(6)}`;

          navigator.geolocation.getCurrentPosition(position => {
            const lat1 = position.coords.latitude;
            const lon1 = position.coords.longitude;
            const lat2 = goal.lat;
            const lon2 = goal.lon;

            const dLon = (lon2 - lon1) * (Math.PI/180);
            const y = Math.sin(dLon) * Math.cos(lat2 * (Math.PI/180));
            const x = Math.cos(lat1 * (Math.PI/180)) * Math.sin(lat2 * (Math.PI/180))
                     - Math.sin(lat1 * (Math.PI/180)) * Math.cos(lat2 * (Math.PI/180)) * Math.cos(dLon);
            const bearing = (Math.atan2(y, x) * (180/Math.PI) + 360) % 360;

            updateCompass(bearing);
          }, error => {
            console.error("Error getting current position:", error);
          });
        })
        .catch(err => console.error(err));
    }

    document.getElementById('enableCompassBtn').addEventListener('click', () => {
      setupDeviceOrientation();
    });

    document.getElementById('closeModal').addEventListener('click', () => {
      document.getElementById('readingModal').style.display = 'none';
    });

    document.getElementById('cancelReadingBtn').addEventListener('click', () => {
      document.getElementById('readingModal').style.display = 'none';
    });

    document.getElementById('confirmReadingBtn').addEventListener('click', () => {
      document.getElementById('readingModal').style.display = 'none';
      document.getElementById('getReadingBtn').click();
    });

    function generateMockSensorData() {
      const VWC = parseFloat(document.getElementById("VMCInput").value)
      const TEMP = (Math.random() * 40).toFixed(2);
      const EC = (Math.random() * 10000).toFixed(0);
      const data = `${VWC},${TEMP},${EC}`;
      const encoder = new TextEncoder();
      const fakeEvent = {
        target: {
          value: encoder.encode(data)
        }
      };
      handleSensorData(fakeEvent);
    }

    // NEW CODE TO CONTINUOUSLY UPDATE CURRENT POSITION
    function startWatchingPosition() {
      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(
          (position) => {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;
            document.getElementById("currentPosition").innerText =
              `Lat: ${lat.toFixed(6)}, Lon: ${lon.toFixed(6)}`;
          },
          (error) => {
            console.error("Error watching position:", error);
          },
          {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 10000
          }
        );
      } else {
        console.error("Geolocation is not supported in this browser.");
      }
    }

    // Start watching position when page loads
    startWatchingPosition();

  </script>

</body>
</html>

